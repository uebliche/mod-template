buildscript {
    configurations.classpath {
        def pluginApiAttr = org.gradle.api.attributes.plugin.GradlePluginApiVersion.GRADLE_PLUGIN_API_VERSION_ATTRIBUTE
        attributes.attribute(pluginApiAttr, project.objects.named(org.gradle.api.attributes.plugin.GradlePluginApiVersion, "9.2.0"))
    }
    ext.computeFabricLoomVersion = { Project proj ->
        def versions = []
        if (proj.rootProject.ext.has('mcmetaFabricLoomVersions')) {
            def value = proj.rootProject.ext.mcmetaFabricLoomVersions
            if (value instanceof Iterable) {
                versions = value.collect { it.toString().trim() }.findAll { it }
            }
        }
        def stable = proj.rootProject.ext.has('mcmetaFabricLoomStableVersion')
                ? proj.rootProject.ext.mcmetaFabricLoomStableVersion?.toString()?.trim()
                : null
        def snapshot = proj.rootProject.ext.has('mcmetaFabricLoomSnapshotVersion')
                ? proj.rootProject.ext.mcmetaFabricLoomSnapshotVersion?.toString()?.trim()
                : null
        def candidate = null
        if (!versions.isEmpty()) {
            def gradleVersion = org.gradle.util.GradleVersion.current().version
            def gradleMajor = (gradleVersion?.tokenize('.')?.first() ?: "0") as int
            if (gradleMajor < 9) {
                candidate = versions.find { !it.startsWith("1.15.") }
            }
            if (!candidate) {
                candidate = versions[0]
            }
        }
        if (!candidate) {
            candidate = stable ?: snapshot
        }
        if (candidate != null && candidate.toString().trim()) {
            return candidate.toString().trim()
        }
        throw new GradleException("mcmeta Fabric Loom version missing. Enable mcmeta and ensure loom data is published.")
    }
    ext.fabricLoomVersion = computeFabricLoomVersion(project)

    repositories {
        maven {
            name = 'Fabric'
            url = 'https://maven.fabricmc.net/'
            metadataSources {
                mavenPom()
                artifact()
            }
        }
    }
    dependencies {
        classpath "net.fabricmc:fabric-loom:${fabricLoomVersion}"
    }
}

plugins {
    id 'systems.manifold.manifold-gradle-plugin' version "${manifold_plugin_version}"
    id 'maven-publish'
    alias(libs.plugins.shadow)
    alias(libs.plugins.minotaur)
    alias(libs.plugins.blossom)
}

apply plugin: 'fabric-loom'
// build.main.gradle


import groovy.json.JsonOutput
import groovy.json.JsonSlurper

project.version = project.hasProperty("tag") ? project.tag : "dev"

def requireMcmetaExtra(String key, String label) {
    if (!project.rootProject.ext.has(key)) {
        throw new GradleException("mcmeta missing ${label} (${key}). Enable the mcmeta plugin.")
    }
    def value = project.rootProject.ext.get(key)
    if (value == null || !value.toString().trim()) {
        throw new GradleException("mcmeta ${label} is empty (${key}).")
    }
    return value.toString().trim()
}

def resolveMinecraftVersion = {
    requireMcmetaExtra("mcmetaMinecraftVersion", "minecraftVersion")
}

project.ext.minecraft_version = resolveMinecraftVersion()

def resolvedMinecraftVersion = project.minecraft_version

group = project.maven_group

base {
    archivesName = project.archives_base_name
}

def isDebugMode() {
    return System.getenv("DEBUG")?.toBoolean() ?: false
}

// -------------------- VERSION HANDLING --------------------

static def parseVersion(String v) {
    def parts = v.tokenize('.').collect {
        def numeric = it.replaceAll(/[^0-9].*/, "")
        numeric ? numeric as int : 0
    }
    while (parts.size() < 3) parts += 0
    return parts[0] * 10000 + parts[1] * 100 + parts[2]
}

static def getJavaVersionForMinecraft(String mcVersion) {
    def v = parseVersion(mcVersion)
    if (v >= parseVersion("1.21.0")) return JavaVersion.VERSION_21
    if (v >= parseVersion("1.20.0")) return JavaVersion.VERSION_17
    if (v >= parseVersion("1.17.0")) return JavaVersion.VERSION_17
    return JavaVersion.VERSION_17
}

def effectiveJavaVersion = getJavaVersionForMinecraft(resolvedMinecraftVersion)

tasks.register('generatePreprocessorDefinitions') {
    doLast {
        def mcVersion = resolvedMinecraftVersion
        List<String> versions = []
        try {
            def manifest = new JsonSlurper().parse(new URL("https://piston-meta.mojang.com/mc/game/version_manifest_v2.json"))
            versions = manifest.versions.findAll { it.type == "release" }*.id
            versions = versions.sort { a, b -> parseVersion(a) <=> parseVersion(b) }
        } catch (Exception ex) {
            throw new GradleException("Failed to download Minecraft versions from Mojang manifest: ${ex.message}")
        }
        def index = versions.indexOf(mcVersion)
        if (index == -1) {
            throw new GradleException("Minecraft ${mcVersion} not present in Mojang release manifest.")
        }
        def sb = new StringBuilder("# DO NOT TOUCH THIS FILE, it is handled by the build script\n")
        versions.eachWithIndex { v, i ->
            sb << "MC_${v.replace('.', '_')}=${i}\n"
            if (i == index) sb << "MC_VER=${i}\n"
        }
        new File(project.projectDir, "build.properties").text = sb.toString()
        println "ðŸ“ build.properties written with ${versions.size()} versions (MC_VER=${index}) for Minecraft ${mcVersion}."
        println "Available versions: ${versions.join(', ')}"
        println "Selected version: ${versions[index]} (index ${index})"
        println "Java version for Minecraft ${mcVersion}: ${effectiveJavaVersion.majorVersion}"
        println "Build properties file written to: ${new File(project.projectDir, "build.properties").absolutePath}"
        println sb.toString()
    }
}
tasks.named("compileJava") { dependsOn generatePreprocessorDefinitions }

// -------------------- MANIFOLD COMPILER ARGS --------------------
def baseCompilerArgs = [
        "-Xplugin:Manifold",
        "-Xlint:unchecked",
        "-Xlint:deprecation"
]

tasks.withType(JavaCompile).configureEach {
    doFirst {
        println "ðŸ”§ Configuring JavaCompile task for Manifold and Minecraft versions..."
        def propsFile = file("build.properties")
        def macroArgs = []
        if (propsFile.exists()) {
            def props = new Properties()
            propsFile.withInputStream { props.load(it) }
            props.each { k, v ->
                macroArgs += "-A${k}=${v}"
            }
        }
        def mcVer = resolvedMinecraftVersion
        def versionInt = mcVer.tokenize('.').collect { it.padLeft(2, '0') }.join('').toInteger()
        println "ðŸ”§ Setting Manifold compiler arguments for Minecraft version ${mcVer} (int: ${versionInt})"
        options.compilerArgs.clear()
        options.compilerArgs.addAll(baseCompilerArgs + macroArgs)
        println "ðŸ”§ Compiler arguments: ${options.compilerArgs.join(' ')}"
    }
    options.release = Integer.parseInt(effectiveJavaVersion.majorVersion)
}

// -------------------- Dependency Resolution --------------------
// This function resolves the correct Fabric loader and API versions for the given Minecraft version.
def resolveFabricVersions(String mcVersion) {
    def mcmetaMc = requireMcmetaExtra("mcmetaMinecraftVersion", "minecraftVersion")
    if (mcmetaMc != mcVersion) {
        throw new GradleException("mcmeta minecraftVersion ${mcmetaMc} does not match requested ${mcVersion}")
    }
    def loader = requireMcmetaExtra("mcmetaFabricLoaderVersion", "Fabric loader")
    def api = requireMcmetaExtra("mcmetaFabricApiVersion", "Fabric API")
    println "ðŸ§© Using mcmeta Fabric loader ${loader}"
    println "ðŸ§© Using mcmeta Fabric API ${api}"
    return [loader: loader, api: api]
}

// Resolve the loader and API version for the current Minecraft version
// and store them in project properties for later use

def resolved = resolveFabricVersions(resolvedMinecraftVersion)
ext.loader_version = resolved.loader
ext.fabric_version = resolved.api

// -------------------- Dependencies --------------------
// Define all dependencies for the project, including annotation processors, Minecraft, mappings, loader, API, and runtime mods

dependencies {
    annotationProcessor libs.manifold // Manifold annotation processor
    minecraft "com.mojang:minecraft:${resolvedMinecraftVersion}" // Minecraft main dependency
    mappings loom.officialMojangMappings() // Official Mojang mappings
    modImplementation "net.fabricmc:fabric-loader:${loader_version}" // Fabric loader
    modImplementation "net.fabricmc.fabric-api:fabric-api:${fabric_version}" // Fabric API

    // Add SLF4J logging dependencies for Minecraft 1.16
    if (resolvedMinecraftVersion.startsWith("1.16")) {
        implementation libs.slf4j.api
        runtimeOnly libs.slf4j.simple
        println "ðŸ“¦ SLF4J enabled for Minecraft ${mcVersion}"
    }
}

sourceSets {
    main {
        blossom {
            javaSources {
                property("COMMIT", System.getenv("GITHUB_SHA") ?: "LOCAL")
                property("BRANCH", System.getenv("GITHUB_REF") ?: "LOCAL")
                property("GROUP", project.group.toString())
                property("ARTIFACT", project.name)
                property("VERSION", project.version.toString())
                property("MC_VERSION", resolvedMinecraftVersion)
                property("VERSION_TYPE", project.hasProperty("version_type") ? project.version_type : "dev")
            }
        }
    }
}

def libs = project.extensions.findByType(VersionCatalogsExtension).named("libs")

manifold {
    manifoldVersion = libs.findVersion("manifold").get().requiredVersion
}

// -------------------- ShadowJar Configuration --------------------
// This block configures the shadowJar task to use the 'shadow' configuration.
shadowJar {
    configurations = [project.configurations.shadow]
}

// -------------------- Assemble Task Dependency --------------------
// Ensure that the assemble task depends on shadowJar so the shadow JAR is built automatically.
tasks.assemble.dependsOn tasks.shadowJar

// -------------------- Resource Processing --------------------
// This block expands variables in fabric.mod.json during the build process.
processResources {

    // Get all unique git authors for the authors field
    def authors = []
    def proc = "git log --format=%aN".execute()
    proc.in.eachLine { line ->
        def name = line.trim().replaceAll(/^'+|'+$/, "")
        if (name && !authors.contains(name)) {
            authors << name
        }
    }
    authors.sort()

    // Serialize authors array as JSON string for safe insertion
    def authorsJson = JsonOutput.toJson(authors)

    // Initialize contact as empty map, not closure!
    def contact = [:]
    if (project.hasProperty("homepage"))
        contact["homepage"] = project.homepage
    if (project.hasProperty("issues"))
        contact["issues"] = project.issues
    if (project.hasProperty("sources"))
        contact["sources"] = project.sources

    def contactJson = JsonOutput.toJson(contact)
    println "ðŸ“œ Authors: ${authors.size()} unique contributors found."
    println "ðŸ“ž Contact info: ${contactJson}"


    def custom = [:]
    def modmenu = [:]
    def modmenu_links = [:]
    if (project.hasProperty("discord"))
        modmenu_links["modmenu.discord"] = project.discord
    modmenu["links"] = modmenu_links
    custom["modmenu"] = modmenu

    def customJson = JsonOutput.toJson(custom)
    println "ðŸ”§ Custom data: ${customJson}"

    def entrypoints = [:]
    if (project.hasProperty("client_main_class")) {
        def clientEntrypoints = [project.client_main_class]
        entrypoints["client"] = clientEntrypoints
        println "ðŸ‘¤ Client entrypoint: ${project.client_main_class}"
    }
    if (project.hasProperty("server_main_class")) {
        def serverEntrypoints = [project.server_main_class]
        entrypoints["server"] = serverEntrypoints
        println "ðŸ‘¥ Server entrypoint: ${project.server_main_class}"
    }
    if (project.hasProperty("common_main_class")) {
        def commonEntrypoints = [project.common_main_class]
        entrypoints["common"] = commonEntrypoints
        println "ðŸŒ Common entrypoint: ${project.common_main_class}"
    }

    def entrypointsJson = JsonOutput.toJson(entrypoints)
    println "ðŸ“‚ Entrypoints: ${entrypointsJson}"


    def enviroment = "*"
    if (project.hasProperty("client_main_class") && project.hasProperty("server_main_class")) {
        enviroment = "*"
    } else if (project.hasProperty("client_main_class")) {
        enviroment = "client"
    } else if (project.hasProperty("server_main_class")) {
        enviroment = "server"
    }
    println "ðŸŒ Environment: ${enviroment}"


    // Use project.name for mod_id (lowercase), mod_name (title case), and icon_path if not set, empty string for others
    filesMatching("fabric.mod.json") {
        expand([
                "version"             : version,
                "mod_id"              : project.hasProperty("mod_id") ? project.mod_id : project.name.toLowerCase(),
                "mod_name"            : project.hasProperty("mod_name") ? project.mod_name : project.name.tokenize(' _-').collect { it.capitalize() }.join(' '),
                "description"         : project.hasProperty("description") ? project.description : "",
                "icon_path"           : project.hasProperty("icon_path") ? project.icon_path : "assets/${project.name}/icon.png",
                "minecraft_version"   : resolvedMinecraftVersion,
                "fabricloader_version": project.hasProperty("loader_version") ? project.loader_version : "",
                "license_type"        : project.hasProperty("license_type") ? project.license_type : "",
                "java_version"        : effectiveJavaVersion.majorVersion,
                "environment"         : project.hasProperty("environment") ? project.environment : enviroment,
                "authors"             : authorsJson,
                "contact"             : contactJson,
                "custom"              : customJson,
                "entrypoints"         : entrypointsJson
        ])
        filter { line ->
            line = line.replace("\"authors\": []", "\"authors\": ${authorsJson}")
            line = line.replace("\"contact\": {}", "\"contact\": ${contactJson}")
            line = line.replace("\"entrypoints\": {}", "\"entrypoints\": ${entrypointsJson}")
            line = line.replace("\"custom\": {}", "\"custom\": ${customJson}")
            return line
        }
    }

    // Dynamically set compatibilityLevel in mod-template.mixins.json based on effectiveJavaVersion
    filesMatching("mod-template.mixins.json") {
        expand([
                "compatibilityLevel": "JAVA_${effectiveJavaVersion.majorVersion}"
        ])
    }
}

// Nach processResources Task: fabric.mod.json ausgeben
tasks.named("processResources").configure {
    doLast {
        def modJsonFile = file("build/resources/main/fabric.mod.json")
        println "----- fabric.mod.json -----"
        println modJsonFile.text
        println "--------------------------"
    }
}

// -------------------- Java Configuration --------------------
// Configure Java compilation settings and source JAR generation.
java {
    withSourcesJar() // Also generate a sources JAR for IDEs and publishing
    targetCompatibility = effectiveJavaVersion // Set Java target compatibility based on Minecraft version
}

jar {
    inputs.property "archivesName", project.base.archivesName
    from("LICENSE.md") { rename { "${it}_${inputs.properties.archivesName}" } }
}

publishing {
    publications {
        create("mavenJava", MavenPublication) {
            artifactId = project.archives_base_name
            from components.java
        }
    }
    repositories {
        // Define publishing destinations here
    }
}

remapJar {
    dependsOn shadowJar
    inputFile = shadowJar.archiveFile.get()
    archiveFileName = "${project.archives_base_name}-${version}.jar"
}
def changelogText = file('release-notes.md').exists() ? file('release-notes.md').text : "No changelog provided."

modrinth {
    println "ðŸ”— Configuring Modrinth upload..."
    debugMode = isDebugMode()
    syncBodyFrom = rootProject.file("README.md").text
    token = System.getenv("MODRINTH_TOKEN")
    projectId = project.modrinth_projectId
    versionNumber = version
    versionName = "${archives_base_name}-${minecraft_version}+${version}"
    versionType = project.hasProperty("version_type") ? project.version_type : "release"
    uploadFile = remapJar
    gameVersions = ["${resolvedMinecraftVersion}"]
    loaders = ["fabric"]
    dependencies {
        required.project "fabric-api"
    }
    changelog = changelogText
}

task updateAuthors {
    doLast {
        def authors = []
        def proc = "git log --format=%aN".execute() // without single quotes
        proc.in.eachLine { line ->
            def name = line.trim().replaceAll(/^'+|'+$/, "") // removes leading and trailing '
            if (name && !authors.contains(name)) {
                authors << name
            }
        }
        authors.sort()
        def jsonFile = file("src/main/resources/fabric.mod.json")
        def json = new JsonSlurper().parse(jsonFile)
        json.authors = authors
        jsonFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
        println "Authors updated: " + authors
    }
}


dependencies {
    implementation project(':common')
}
