import groovy.json.JsonSlurper
import groovy.xml.XmlSlurper
import org.gradle.jvm.toolchain.JavaLanguageVersion
import org.gradle.util.VersionNumber

buildscript {
    ext.computeNeoForgeModdevVersion = { Project proj ->
        if (proj.hasProperty("neoforge_gradle_version") && proj.property("neoforge_gradle_version")?.toString()?.trim()) {
            return proj.property("neoforge_gradle_version").toString().trim()
        }
        if (proj.rootProject.ext.has('latestNeoForgeModdevVersion')) {
            return proj.rootProject.ext.latestNeoForgeModdevVersion
        }
        try {
            def metadataText = new URL("https://maven.neoforged.net/releases/net/neoforged/moddev/net.neoforged.moddev.gradle.plugin/maven-metadata.xml").text
            def metadata = new XmlSlurper().parseText(metadataText)
            def candidate = metadata.versioning.release?.text()
            if (!candidate || candidate.isBlank()) {
                candidate = metadata.versioning.latest?.text()
            }
            if (!candidate || candidate.isBlank()) {
                def versions = metadata.versioning.versions.version*.text()
                candidate = versions?.last()
            }
            candidate = candidate ?: "2.0.107"
            proj.rootProject.ext.latestNeoForgeModdevVersion = candidate
        } catch (Exception ex) {
            println "⚠️  Failed to resolve NeoForge Gradle plugin version: ${ex.message}; falling back to 2.0.107"
            proj.rootProject.ext.latestNeoForgeModdevVersion = "2.0.107"
        }
        return proj.rootProject.ext.latestNeoForgeModdevVersion
    }
    ext.neoForgeModdevVersion = computeNeoForgeModdevVersion(project)
}

plugins {
    id 'net.neoforged.moddev' version "${neoForgeModdevVersion}"
    id 'maven-publish'
}

def forgeTaskRequested = gradle.startParameter.taskRequests.any { request ->
    request.args.any { arg ->
        arg.contains("loader-neoforge")
    }
}
def skipNeoForge = project.findProperty("skipNeoForge")?.toString()?.toBoolean()
if (skipNeoForge == null) {
    skipNeoForge = project.findProperty("skipForge")?.toString()?.toBoolean()
}
skipNeoForge = skipNeoForge ?: false
def forceNeoForge = project.findProperty("forceNeoForge")?.toString()?.toBoolean()
if (forceNeoForge == null) {
    forceNeoForge = project.findProperty("forceForge")?.toString()?.toBoolean()
}
forceNeoForge = forceNeoForge ?: false

if ((skipNeoForge || !forgeTaskRequested) && !forceNeoForge) {
    logger.lifecycle("Skipping loader-neoforge configuration (no loader-neoforge tasks requested)")
    return
}

// Ensure we can reference the shared common source set when wiring NeoForge mods
evaluationDependsOn(':common')

group = project.maven_group
version = project.findProperty("tag") ?: "0.0.0-dev"

base {
    archivesName = project.archives_base_name
}

java {
    withSourcesJar()
}

def parseMcVersionNumber = { String version ->
    if (!version) {
        return null
    }
    def parts = version.tokenize('.').collect { it as int }
    while (parts.size() < 3) {
        parts << 0
    }
    parts[0] * 10000 + parts[1] * 100 + parts[2]
}

def determineJavaMajor = { String mcVersion ->
    def numeric = parseMcVersionNumber(mcVersion)
    if (numeric == null) {
        return 21
    }
    if (numeric >= parseMcVersionNumber("1.21.0")) return 21
    return 17
}

dependencies {
    implementation project(':common')
}

def requestedMcVersion = (project.hasProperty("mcVersion") ? project.property("mcVersion") : null)
if (!requestedMcVersion && project.rootProject.ext.has("mcmetaMinecraftVersion")) {
    def mcmetaValue = project.rootProject.ext.mcmetaMinecraftVersion
    if (mcmetaValue != null && mcmetaValue.toString().trim()) {
        requestedMcVersion = mcmetaValue.toString()
    }
}
if (!requestedMcVersion) {
    requestedMcVersion = project.minecraft_version
}
requestedMcVersion = requestedMcVersion.toString()
def javaMajor = determineJavaMajor(requestedMcVersion)

java {
    toolchain.languageVersion = JavaLanguageVersion.of(javaMajor)
}

tasks.withType(JavaCompile).configureEach {
    options.release = javaMajor
}

def loadNeoForgeMetadata = {
    if (!rootProject.ext.has('cachedNeoForgeVersions')) {
        def metadataUrl = new URL("https://maven.neoforged.net/releases/net/neoforged/neoforge/maven-metadata.xml")
        rootProject.logger.lifecycle("Downloading NeoForge metadata from ${metadataUrl}")
        def xmlText = metadataUrl.text
        def xml = new XmlSlurper().parseText(xmlText)
        rootProject.ext.cachedNeoForgeVersions = xml.versioning.versions.version*.text()
        if (!rootProject.ext.cachedNeoForgeVersions) {
            throw new GradleException("Failed to load NeoForge versions from ${metadataUrl}")
        }
    }
    rootProject.ext.cachedNeoForgeVersions
}

def resolveMcmetaNeoForgeVersion = { String mcVersion ->
    if (!rootProject.ext.has("mcmetaMinecraftVersion")) {
        return null
    }
    def mcmetaMc = rootProject.ext.mcmetaMinecraftVersion?.toString()
    if (!mcmetaMc || mcmetaMc != mcVersion) {
        return null
    }
    if (!rootProject.ext.has("mcmetaNeoForgeVersion")) {
        return null
    }
    def value = rootProject.ext.mcmetaNeoForgeVersion
    if (value == null || !value.toString().trim()) {
        return null
    }
    return value.toString().trim()
}

def resolveNeoForgeVersion = { String mcVersion ->
    if (project.hasProperty("neoForgeVersion")) {
        return project.property("neoForgeVersion").toString()
    }
    def mcmetaVersion = resolveMcmetaNeoForgeVersion(mcVersion)
    if (mcmetaVersion) {
        return mcmetaVersion
    }

    def parts = mcVersion.tokenize('.').collect { it as int }
    if (parts.size() < 2) {
        throw new GradleException("Cannot derive NeoForge version for Minecraft ${mcVersion}")
    }
    def suffix = parts.subList(1, parts.size()).collect { it.toString() }
    if (suffix.size() == 1) {
        suffix << "0"
    }
    def prefix = suffix.join('.')
    def matching = loadNeoForgeMetadata().findAll { it.startsWith(prefix) }
    if (matching.isEmpty()) {
        throw new GradleException("No NeoForge version matching prefix ${prefix} (derived from Minecraft ${mcVersion})")
    }
    return matching.max { VersionNumber.parse(it) }
}

def neoForgeVersion = resolveNeoForgeVersion(requestedMcVersion)

def deriveLoaderVersionRange = {
    def parts = neoForgeVersion.tokenize('.')
    def major = parts[0].toInteger()
    def upperBound = major + 1
    return "[4,${upperBound})"
}

def loaderVersionRange = deriveLoaderVersionRange()

def modId = (project.findProperty('mod_id') ?: 'modtemplate').toString()

def runDir = project.layout.projectDirectory.dir('run')

def expandedProperties = [
        modId                : modId,
        modVersion           : project.version.toString(),
        minecraftVersion     : requestedMcVersion,
        neoforgeVersionRange : loaderVersionRange
]

neoForge {
    version = neoForgeVersion

    runs {
        configureEach {
            systemProperty 'mod.mcVersion', requestedMcVersion
        }
        client {
            client()
            logLevel = org.slf4j.event.Level.INFO
            gameDirectory = runDir.dir("client-${requestedMcVersion}").asFile
        }
        server {
            server()
            gameDirectory = runDir.dir("server-${requestedMcVersion}").asFile
        }
        data {
            data()
            gameDirectory = runDir.dir("data-${requestedMcVersion}").asFile
        }
    }

    mods {
        create(modId) {
            sourceSet sourceSets.main
            sourceSet project(':common').sourceSets.main
        }
    }
}

tasks.withType(ProcessResources).configureEach {
    inputs.properties(expandedProperties)
    filesMatching('META-INF/neoforge.mods.toml') {
        expand(expandedProperties)
    }
}
